2.1 : Програма встановлює max_time у максимальне значення для 64-бітного time_t та використовує ctime() для перетворення мітки часу в читабельний формат.
2.2 : Спочатку створюємо базову програму яка виводить текст. Наступний запуск додаємо глобалиний масив, потім ініціалізуємо ций масив і в кінці створюємо локальний масив всередині функції. 
      В другому запускі секція .bss збільшилася, оскільки масив знаходиться в неініціалізованій пам'яті.  
      В третьому запускі секція .data зросла через ініціалізований масив, а секція .bss зменшилася, бо тепер змінні явно зберігаються в сегменті .data. 
      Можемо зкомпілювати програму з оптимізацією через -O3. .text може зменшитися через видалення зайвого коду. 
      Отже, сегмент .data зберігається у виконуваному файлі, сегмент .bss не зберігається, але його розмір враховується. Оптимізація впливає на .text, але не на .data і .bss.
2.3 : При компіляції та виведенні інформації на екрані можна побачити адреси пам'яті для кожного сегменту. Потім додаю у функцію великі локальні масиви, щоб побачити, як змінюється вершина стека. 
      Після виділення великого масиву стек змістився вниз (адреса зменшилася).
2.4 : При запускі програма виведе адреси локальних змінних і заблокується на pause(). Переглянути стек через gstack швидше та неінтерактивне, але GDB дає більше можливостей (наприклад, розглянути змінні).
2.5 :  1. Як працює виклик процедур зі стеком і IP (Instruction Pointer) - При виклику функції процесор зберігає в стеку адресу повернення, а потім переходить до нової функції.
            Після завершення функції ця адреса повернення дістається зі стека, і процесор продовжує виконання з цієї точки.
        2. Чи можна обійтися без IP, використовуючи вершину стека? - Ні, бо IP потрібен для вибору наступної інструкції.
        4. Що б сталося без IP? - Ми втратимо можливість знати, де знаходиться наступна інструкція після повернення.
2.10 : При запуску програми ОС використовує динамічне завантаження бібліотек. Спочатку, вона має виявити необхідні бібліотеки (Під час компіляції та компоновки програми вказуються бібліотеки, які необхідно завантажити (gcc -o program program.c -lmylib)),
        Потім виконується пошук бібліотек (завантаження бібліотек в пам'ять, виконання ініціалізаційного коду), виконується аналіз завантажених бібліотек та динамічне завантаження під час виконання.
        На прикладі я створюю просту динамічну бібліотеку, яка міститиме функцію для додавання двох чисел. Компілюю через -shared щоб створити динамічну бібліотеку та -fPIC щоб дозволити динамічне завантаження.
        Потім створюю програму, яка переймає функцію add() з створенної бібліотеки. Компілюю через -L.(шукає бібліотеку в поточному каталозі) та -lexample (підключення до бібліотеки). Запускаю так: LD_LIBRARY_PATH=. ./main і отримую очікуванний результат.
        Тому, динамічні бібліотеки економлять пам'ять та дозволяють використовувати один .so файл для декількох програм
